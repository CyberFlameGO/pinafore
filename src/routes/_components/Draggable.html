<div class="draggable-area {draggableClassAfterRaf}"
     on:pointermove="onPointerMove(event)"
     on:pointerleave="onPointerLeave(event)"
     on:click="onClick(event)"
     ref:area
>
  <div class="draggable-indicator {indicatorClassAfterRaf}"
       style={indicatorStyleAfterRaf}
       on:pointerdown="onPointerDown(event)"
       on:pointerup="onPointerUp(event)"
       ref:indicator
  >
    <div class="draggable-indicator-inner">
      <slot></slot>
    </div>
  </div>
</div>
<style>
  .draggable-area {
    position: relative;
    touch-action: none;
  }
  .draggable-indicator {
    position: absolute;
    cursor: pointer;
  }
  .draggable-indicator-inner {
    pointer-events: none;
    display: flex;
  }
</style>
<script>
  import { observe } from 'svelte-extras'
  import { throttleRequestAnimationFrame, throttleRequestPostAnimationFrame } from '../_utils/throttleRequestAnimationFrame'

  // ensure DOM writes only happen once after a rAF
  const updateIndicatorStyle = throttleRequestAnimationFrame()
  const updateIndicatorClass = throttleRequestAnimationFrame()
  const updateDraggableClass = throttleRequestAnimationFrame()

  // ensure DOM reads only happen once after a rPAF
  const calculateGBCR = throttleRequestPostAnimationFrame()

  const clamp = x => Math.max(0, Math.min(1, x))

  export default {
    oncreate () {
      this.observe('dragging', dragging => {
        if (dragging) {
          this.fire('dragStart')
        } else {
          this.fire('dragEnd')
        }
      }, { init: false })
      this.observe('indicatorStyle', indicatorStyle => {
        updateIndicatorStyle(() => {
          this.set({ indicatorStyleAfterRaf: indicatorStyle })
        })
      })
      this.observe('indicatorClass', indicatorClass => {
        updateIndicatorClass(() => {
          this.set(({ indicatorClassAfterRaf: indicatorClass }))
        })
      })
      this.observe('draggableClass', draggableClass => {
        updateDraggableClass(() => {
          this.set({ draggableClassAfterRaf: draggableClass })
        })
      })
    },
    data: () => ({
      dragging: false,
      draggableClass: '',
      dragglableClassAfterRaf: '',
      indicatorClass: '',
      indicatorClassAfterRaf: '',
      x: 0,
      y: 0,
      indicatorWidth: 0,
      indicatorHeight: 0,
      indicatorStyleAfterRaf: ''
    }),
    computed: {
      indicatorStyle: ({ x, y, indicatorWidth, indicatorHeight }) => (
        `left: calc(${x * 100}% - ${indicatorWidth / 2}px); top: calc(${y * 100}% - ${indicatorHeight / 2}px);`
      )
    },
    methods: {
      observe,
      onPointerDown (e) {
        console.log('Draggable: onPointerDown')
        e.preventDefault()
        e.stopPropagation()
        const rect = this.refs.indicator.getBoundingClientRect()
        this.set({
          dragging: true,
          dragOffsetX: e.clientX - rect.left,
          dragOffsetY: e.clientY - rect.top
        })
      },
      onPointerMove (e) {
        console.log('Draggable: onPointerMove')
        if (this.get().dragging) {
          console.log('Draggable: dragging')
          e.preventDefault()
          e.stopPropagation()
          const { indicatorWidth, indicatorHeight, dragOffsetX, dragOffsetY } = this.get()
          calculateGBCR(() => {
            const rect = this.refs.area.getBoundingClientRect()
            const offsetX = dragOffsetX - (indicatorWidth / 2)
            const offsetY = dragOffsetY - (indicatorHeight / 2)
            const x = clamp((e.clientX - rect.left - offsetX) / rect.width)
            const y = clamp((e.clientY - rect.top - offsetY) / rect.height)
            this.set({ x, y })
            this.fire('change', { x, y })
          })
        }
      },
      onPointerUp (e) {
        console.log('Draggable: onPointerUp')
        e.preventDefault()
        e.stopPropagation()
        this.set({ dragging: false })
      },
      onPointerLeave (e) {
        console.log('Draggable: onPointerLeave')
        e.preventDefault()
        e.stopPropagation()
        this.set({ dragging: false })
      },
      onClick (e) {
        console.log('Draggable: onClick')
        if (!e.target.classList.contains('draggable-indicator')) {
          console.log('Draggable: onClick handled')
          e.preventDefault()
          e.stopPropagation()
          const rect = this.refs.area.getBoundingClientRect()
          const x = clamp((e.clientX - rect.left) / rect.width)
          const y = clamp((e.clientY - rect.top) / rect.height)
          this.set({ x, y })
          this.fire('change', { x, y })
        }
      }
    }
  }
</script>
